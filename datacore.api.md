## API Report File for "datacore"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { App } from 'obsidian';
import { Component } from 'obsidian';
import { ComponentChildren } from 'preact';
import { DateTime } from 'luxon';
import { Duration } from 'luxon';
import { EventRef } from 'obsidian';
import { Events } from 'obsidian';
import { FileManager } from 'obsidian';
import * as hooks from 'preact/hooks';
import { HTMLAttributes } from 'preact/compat';
import { JSX as JSX_2 } from 'preact/compat';
import { JSX as JSX_3 } from 'preact/jsx-runtime';
import { JSX as JSX_4 } from 'preact';
import * as luxon_2 from 'luxon';
import { MarkdownPostProcessorContext } from 'obsidian';
import { MarkdownRenderChild } from 'obsidian';
import { MetadataCache } from 'obsidian';
import { Plugin as Plugin_2 } from 'obsidian';
import * as preact_2 from 'preact';
import { PropsWithChildren } from 'preact/compat';
import { Queue } from '@datastructures-js/queue';
import { default as React_2 } from 'preact/compat';
import { ReactNode } from 'preact/compat';
import { TFile } from 'obsidian';
import { Vault } from 'obsidian';
import { VNode } from 'preact';

// @public
export type ArrayComparator<T> = (a: T, b: T) => number;

// @public
export type ArrayFunc<T, O> = (elem: T, index: number, arr: T[]) => O;

// @public
export class Canvas implements Linkable, File_2, Linkbearing, Taggable, Indexable, Fieldbearing {
    // Warning: (ae-forgotten-export) The symbol "BaseCanvasCard" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    $cards: BaseCanvasCard[];
    // (undocumented)
    $ctime: DateTime;
    // (undocumented)
    $extension: string;
    // (undocumented)
    get $file(): string;
    // (undocumented)
    get $id(): string;
    // Warning: (ae-forgotten-export) The symbol "InlineField" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    $infields: Record<string, InlineField>;
    // (undocumented)
    get $link(): Link;
    // (undocumented)
    $links: Link[];
    // (undocumented)
    $mtime: DateTime;
    // (undocumented)
    $path: string;
    // (undocumented)
    $size: number;
    // (undocumented)
    $tags: string[];
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    // (undocumented)
    field(key: string): Field | undefined;
    // (undocumented)
    get fields(): Field[];
    // (undocumented)
    static from(raw: JsonCanvas, normalizer?: LinkNormalizer): Canvas;
    // Warning: (ae-forgotten-export) The symbol "JsonCanvas" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    json(): JsonCanvas;
    // (undocumented)
    static TYPES: string[];
}

// @public
export type CanvasCard = CanvasTextCard | CanvasFileCard | CanvasWebCard;

// @public
export class CanvasFileCard extends BaseCanvasCard implements Indexable {
    // (undocumented)
    $linkedFile: string;
    // (undocumented)
    readonly $type: string;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    // (undocumented)
    static from(raw: JsonCanvasFileCard): CanvasFileCard;
    // Warning: (ae-forgotten-export) The symbol "JsonCanvasFileCard" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    json(): JsonCanvasFileCard;
    // (undocumented)
    static TYPES: string[];
}

// @public
export class CanvasTextCard extends BaseCanvasCard implements Linkbearing, Taggable, Indexable, Fieldbearing {
    // Warning: (ae-forgotten-export) The symbol "CardDimensions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    $dimensions: CardDimensions;
    // (undocumented)
    $file: string;
    // (undocumented)
    $frontmatter?: Record<string, FrontmatterEntry>;
    // (undocumented)
    $id: string;
    // (undocumented)
    $infields: Record<string, InlineField>;
    // (undocumented)
    $links: Link[];
    // (undocumented)
    $parent?: Indexable;
    // (undocumented)
    $revision?: number;
    // (undocumented)
    $sections: MarkdownSection[];
    // (undocumented)
    $tags: string[];
    // (undocumented)
    $title: string;
    // (undocumented)
    $type: string;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    // (undocumented)
    field(key: string): Field | undefined;
    // (undocumented)
    static FIELD_DEF: FieldExtractor<CanvasTextCard>;
    // (undocumented)
    get fields(): Field[];
    // (undocumented)
    static from(raw: JsonCanvasTextCard, file: string, normalizer?: LinkNormalizer): CanvasTextCard;
    // Warning: (ae-forgotten-export) The symbol "JsonCanvasTextCard" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    json(): JsonCanvasTextCard;
    // (undocumented)
    static TYPES: string[];
}

// @public (undocumented)
export class CanvasWebCard extends BaseCanvasCard implements Indexable {
    // (undocumented)
    readonly $type: string;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    // (undocumented)
    $url: string;
    // (undocumented)
    static from(raw: JsonCanvasWebCard, file: string): CanvasWebCard;
    // Warning: (ae-forgotten-export) The symbol "JsonCanvasWebCard" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    json(): JsonCanvasWebCard;
    // (undocumented)
    static TYPES: string[];
}

// @public
export interface DataArray<T> {
    [Symbol.iterator](): Iterator<T>;
    [index: number]: any;
    [field: string]: any;
    array(): T[];
    chain<U>(op: (arr: DataArray<T>) => DataArray<U>): DataArray<U>;
    concat(other: Iterable<T>): DataArray<T>;
    distinct<U>(key?: ArrayFunc<T, U>, comparator?: ArrayComparator<U>): DataArray<T>;
    every(f: ArrayFunc<T, boolean>): boolean;
    expand(key: string): DataArray<any>;
    filter(predicate: ArrayFunc<T, boolean>): DataArray<T>;
    find(pred: ArrayFunc<T, boolean>): T | undefined;
    findIndex(pred: ArrayFunc<T, boolean>, fromIndex?: number): number;
    first(): T | undefined;
    flatMap<U>(f: ArrayFunc<T, U[]>): DataArray<U>;
    forEach(f: ArrayFunc<T, void>): void;
    groupBy<U>(key: ArrayFunc<T, U>, comparator?: ArrayComparator<U>): DataArray<{
        key: U;
        rows: T[];
    }>;
    groupIn<U>(key: ArrayFunc<LowestKey<T>, U>, comparator?: ArrayComparator<U>): DataArray<Ingrouped<U, T>>;
    includes(element: T): boolean;
    indexOf(element: T, fromIndex?: number): number;
    into(key: string): DataArray<any>;
    join(sep?: string): string;
    last(): T | undefined;
    length: number;
    limit(count: number): DataArray<T>;
    map<U>(f: ArrayFunc<T, U>): DataArray<U>;
    mutate(f: ArrayFunc<T, void>): DataArray<T>;
    none(f: ArrayFunc<T, boolean>): boolean;
    slice(start?: number, end?: number): DataArray<T>;
    some(f: ArrayFunc<T, boolean>): boolean;
    sort<U>(key: ArrayFunc<T, U>, direction?: "asc" | "desc", comparator?: ArrayComparator<U>): DataArray<T>;
    sortInPlace<U>(key: (v: T) => U, direction?: "asc" | "desc", comparator?: ArrayComparator<U>): DataArray<T>;
    to(key: string): DataArray<any>;
    where(predicate: ArrayFunc<T, boolean>): DataArray<T>;
}

// @public
export namespace DataArray {
    export function from<T>(raw: Iterable<T>): DataArray<T>;
    export function isDataArray(obj: any): obj is DataArray<any>;
    export function wrap<T>(raw: T[] | DataArray<T>): DataArray<T>;
}

// @public
export class Datacore extends Component {
    constructor(app: App, version: string, settings: Settings);
    // (undocumented)
    app: App;
    datastore: Datastore;
    events: Events;
    // Warning: (ae-forgotten-export) The symbol "FileImporter" needs to be exported by the entry point index.d.ts
    importer: FileImporter;
    index(): void;
    initialize(): void;
    initialized: boolean;
    // Warning: (ae-forgotten-export) The symbol "DatacoreInitializer" needs to be exported by the entry point index.d.ts
    initializer?: DatacoreInitializer;
    metadataCache: MetadataCache;
    off(evt: string, callback: (...data: any) => any): void;
    offref(ref: EventRef): void;
    on(evt: "update", callback: (revision: number) => any, context?: any): EventRef;
    // (undocumented)
    on(evt: "initialized", callback: () => any, context?: any): EventRef;
    // Warning: (ae-forgotten-export) The symbol "LocalStorageCache" needs to be exported by the entry point index.d.ts
    persister: LocalStorageCache;
    read(file: TFile): Promise<string>;
    // Warning: (ae-forgotten-export) The symbol "EmbedQueue" needs to be exported by the entry point index.d.ts
    reads: EmbedQueue;
    reload(file: TFile): Promise<Indexable>;
    get revision(): number;
    // (undocumented)
    settings: Settings;
    // (undocumented)
    storeCanvas(data: Canvas): void;
    storeMarkdown(data: MarkdownPage): void;
    vault: Vault;
    // (undocumented)
    version: string;
}

// @public
export class DatacoreApi {
    constructor(core: Datacore);
    get app(): App;
    array<T>(input: T[] | DataArray<T>): DataArray<T>;
    blockLink(path: string, block: string): Link;
    // Warning: (ae-forgotten-export) The symbol "Coerce" needs to be exported by the entry point index.d.ts
    coerce: typeof Coerce;
    // (undocumented)
    core: Datacore;
    // Warning: (ae-forgotten-export) The symbol "Expression" needs to be exported by the entry point index.d.ts
    evaluate(expression: string | Expression, variables?: Record<string, Literal> | any, sourcePath?: string): Result<Literal, string>;
    executeJs(source: string, container: HTMLElement, component: Component | MarkdownPostProcessorContext, sourcePath: string): MarkdownRenderChild;
    executeJsx(source: string, container: HTMLElement, component: Component | MarkdownPostProcessorContext, sourcePath: string): MarkdownRenderChild;
    executeTs(source: string, container: HTMLElement, component: Component | MarkdownPostProcessorContext, sourcePath: string): MarkdownRenderChild;
    executeTsx(source: string, container: HTMLElement, component: Component | MarkdownPostProcessorContext, sourcePath: string): MarkdownRenderChild;
    fileLink(path: string): Link;
    // Warning: (ae-forgotten-export) The symbol "SearchResult" needs to be exported by the entry point index.d.ts
    fullquery(query: string | IndexQuery): SearchResult<Indexable>;
    headerLink(path: string, header: string): Link;
    local(path: string): DatacoreLocalApi;
    get luxon(): typeof luxon_2;
    page(path: string | Link): MarkdownPage | undefined;
    parseLink(linktext: string): Link;
    parseQuery(query: string | IndexQuery): IndexQuery;
    get preact(): typeof preact_2;
    query(query: string | IndexQuery): Indexable[];
    resolvePath(path: string | Link, sourcePath?: string): string;
    tryEvaluate(expression: string | Expression, variables?: Record<string, Literal> | any, sourcePath?: string): Literal;
    tryFullQuery(query: string | IndexQuery): Result<SearchResult<Indexable>, string>;
    tryParseLink(linktext: string): Result<Link, string>;
    tryParseQuery(query: string | IndexQuery): Result<IndexQuery, string>;
    tryQuery(query: string | IndexQuery): Result<Indexable[], string>;
}

// @public
export class DatacoreLocalApi {
    constructor(api: DatacoreApi, path: string);
    // (undocumented)
    api: DatacoreApi;
    get app(): App;
    array<T>(input: T[] | DataArray<T>): DataArray<T>;
    blockLink(path: string, block: string): Link;
    // Warning: (ae-forgotten-export) The symbol "Button" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    Button: typeof Button;
    // Warning: (ae-forgotten-export) The symbol "Callout" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    Callout: typeof Callout;
    // Warning: (ae-forgotten-export) The symbol "Card" needs to be exported by the entry point index.d.ts
    Card: typeof Card;
    // Warning: (ae-forgotten-export) The symbol "Checkbox" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    Checkbox: typeof Checkbox;
    coerce: typeof Coerce;
    get core(): Datacore;
    createContext: typeof preact_2.createContext;
    currentFile(): MarkdownPage;
    currentPath(): string;
    embed: any;
    evaluate(expression: string | Expression, variables?: Record<string, Literal> | any, sourcePath?: string): Result<Literal, string>;
    fileLink(path: string): Link;
    fullquery(query: string | IndexQuery): SearchResult<Indexable>;
    // Warning: (ae-forgotten-export) The symbol "Group" needs to be exported by the entry point index.d.ts
    Group: typeof Group;
    headerLink(path: string, header: string): Link;
    // Warning: (ae-forgotten-export) The symbol "Icon" needs to be exported by the entry point index.d.ts
    Icon: typeof Icon;
    Link: ({ link, sourcePath: maybeSourcePath }: {
        link: string | Link;
        sourcePath?: string | undefined;
    }) => preact_2.JSX.Element;
    LinkEmbed: any;
    // Warning: (ae-forgotten-export) The symbol "ListView" needs to be exported by the entry point index.d.ts
    List: typeof ListView;
    Literal: any;
    get luxon(): typeof luxon_2;
    Markdown: any;
    parseLink(linktext: string): Link;
    parseQuery(query: string | IndexQuery): IndexQuery;
    // (undocumented)
    path: string;
    get preact(): typeof preact_2;
    query(query: string | IndexQuery): Indexable[];
    require(path: string | Link): Promise<any>;
    resolvePath(path: string | Link, sourcePath?: string): string;
    // Warning: (ae-forgotten-export) The symbol "Slider" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    Slider: typeof Slider;
    SpanEmbed: any;
    // Warning: (ae-forgotten-export) The symbol "Stack" needs to be exported by the entry point index.d.ts
    Stack: typeof Stack;
    // Warning: (ae-forgotten-export) The symbol "Switch" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    Switch: typeof Switch;
    Table: typeof TableView;
    // Warning: (ae-forgotten-export) The symbol "Textbox" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    Textbox: typeof Textbox;
    tryEvaluate(expression: string | Expression, variables?: Record<string, Literal> | any, sourcePath?: string): Literal;
    tryFullQuery(query: string | IndexQuery): Result<SearchResult<Indexable>, string>;
    tryParseLink(linktext: string): Result<Link, string>;
    tryParseQuery(query: string | IndexQuery): Result<IndexQuery, string>;
    tryQuery(query: string | IndexQuery): Result<Indexable[], string>;
    useArray<T, U>(input: T[] | DataArray<T>, process: (data: DataArray<T>) => DataArray<U>, deps?: any[]): U[];
    useCallback: typeof hooks.useCallback;
    useContext: typeof hooks.useContext;
    useCurrentFile(settings?: {
        debounce?: number;
    }): MarkdownPage;
    useCurrentPath(settings?: {
        debounce?: number;
    }): string;
    useEffect: typeof hooks.useEffect;
    useFile(path: string, settings?: {
        debounce?: number;
    }): Indexable | undefined;
    useFullQuery(query: string | IndexQuery, settings?: {
        debounce?: number;
    }): SearchResult<Indexable>;
    useIndexUpdates(settings?: {
        debounce?: number;
    }): number;
    // Warning: (ae-forgotten-export) The symbol "useInterning" needs to be exported by the entry point index.d.ts
    useInterning: typeof useInterning;
    useMemo: typeof hooks.useMemo;
    useQuery(query: string | IndexQuery, settings?: {
        debounce?: number;
    }): Indexable[];
    useReducer: typeof hooks.useReducer;
    useRef: typeof hooks.useRef;
    useState: typeof hooks.useState;
    // Warning: (ae-forgotten-export) The symbol "VanillaSelect" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    VanillaSelect: typeof VanillaSelect;
    // Warning: (ae-forgotten-export) The symbol "TableView" needs to be exported by the entry point index.d.ts
    //
    // @deprecated (undocumented)
    VanillaTable: typeof TableView;
}

// @public
export class DatacorePlugin extends Plugin_2 {
    api: DatacoreApi;
    core: Datacore;
    // (undocumented)
    onload(): Promise<void>;
    // (undocumented)
    onunload(): void;
    registerCodeblockHighlighting(): () => void;
    settings: Settings;
    updateSettings(settings: Partial<Settings>): Promise<void>;
}

// @public
export type DataObject = Record<string, any>;

// @public
export class Datastore {
    constructor(vault: Vault, metadataCache: MetadataCache, settings: Settings);
    clear(): void;
    delete(id: string): boolean;
    // Warning: (ae-forgotten-export) The symbol "Evaluator" needs to be exported by the entry point index.d.ts
    evaluator(sourcePath?: string, globals?: Record<string, Literal>): Evaluator;
    load(id: string): Indexable | undefined;
    load(ids: string[]): Indexable[];
    // (undocumented)
    metadataCache: MetadataCache;
    resolveLink(rawLink: string | Link, sourcePath?: string): Indexable | undefined;
    revision: number;
    // Warning: (ae-forgotten-export) The symbol "SearchSettings" needs to be exported by the entry point index.d.ts
    search(query: IndexQuery, settings?: SearchSettings): Result<SearchResult<Indexable>, string>;
    // (undocumented)
    settings: Settings;
    get size(): number;
    // Warning: (ae-forgotten-export) The symbol "Substorer" needs to be exported by the entry point index.d.ts
    store<T extends Indexable>(object: T | T[], substorer?: Substorer<T>): void;
    touch(): void;
    // (undocumented)
    vault: Vault;
}

// @public
export namespace Extractors {
    export function frontmatter<T extends Indexable>(front: (object: T) => Record<string, FrontmatterEntry> | undefined): FieldExtractor<T>;
    export function inlineFields<T extends Indexable>(inlineMap: (object: T) => Record<string, InlineField> | undefined): FieldExtractor<T>;
    export function intrinsics<T extends Record<string, any>>(except?: Set<string>): FieldExtractor<T>;
    export function merge<T extends Fieldbearing>(...extractors: FieldExtractor<T>[]): FieldExtractor<T>;
}

// @public
export class Failure<T, E> {
    constructor(error: E);
    // (undocumented)
    bimap<T2, E2>(_succ: (a: T) => T2, fail: (b: E) => E2): Result<T2, E2>;
    // (undocumented)
    cast<U>(): Result<U, E>;
    // (undocumented)
    error: E;
    // (undocumented)
    flatMap<U>(_f: (a: T) => Result<U, E>): Result<U, E>;
    // (undocumented)
    map<U>(_f: (a: T) => U): Result<U, E>;
    // (undocumented)
    mapErr<U>(f: (e: E) => U): Result<T, U>;
    // (undocumented)
    orElse(value: T): T;
    // (undocumented)
    orElseThrow(message?: (e: E) => string): T;
    // (undocumented)
    successful: false;
}

// @public
export interface Field {
    key: string;
    provenance?: Provenance;
    raw?: string;
    value: Literal;
}

// @public (undocumented)
export interface Fieldbearing {
    field(key: string): Field | undefined;
    fields: Field[];
}

// @public
export const FIELDBEARING_TYPE = "fields";

// @public (undocumented)
export namespace Fieldbearings {
    export function get(object: Fieldbearing | Record<string, Literal>, key: string): Literal | undefined;
    // (undocumented)
    export function isFieldbearing(object: any): object is Fieldbearing;
}

// @public
export type FieldExtractor<T> = (object: T, key?: string) => Field[];

// @public
interface File_2 extends Linkable {
    $ctime: DateTime;
    $extension: string;
    $mtime: DateTime;
    $path: string;
    $size: number;
}
export { File_2 as File }

// @public
export const FILE_TYPE = "file";

// @public
export interface FrontmatterEntry {
    key: string;
    raw: string;
    value: Literal;
}

// @public
export function gatherLinks(input: Literal): Link[];

// @public
export function gatherTags(data: Record<string, FrontmatterEntry>): string[];

// @public
export class GenericFile implements File_2, Indexable, Fieldbearing, Linkable {
    $ctime: DateTime;
    $extension: string;
    get $file(): string;
    get $id(): string;
    get $link(): Link;
    $mtime: DateTime;
    // (undocumented)
    $path: string;
    $size: number;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    constructor(path: string, ctime: DateTime, mtime: DateTime, size: number);
    // (undocumented)
    field(key: string): Field;
    // (undocumented)
    get fields(): Field[];
    // (undocumented)
    static TYPES: string[];
    value(key: string): Literal | undefined;
}

// @public
export type GroupElement<T> = {
    key: Literal;
    rows: Grouping<T>;
};

// @public
export type Grouping<T> = T[] | GroupElement<T>[];

// @public (undocumented)
export namespace Groupings {
    export function count<T>(elements: Grouping<T> | GroupElement<T>): number;
    export function isElementGroup<T>(entry: any): entry is GroupElement<T>;
    export function isGrouping<T>(entry: Grouping<T>): entry is GroupElement<T>[];
    export function isLeaf<T>(entry: Grouping<T>): entry is T[];
    export function slice<T>(elements: Grouping<T>, start: number, end: number): Grouping<T>;
}

// @public
export const INDEX_ALL: IndexQuery;

// @public
export const INDEX_NONE: IndexQuery;

// @public
export interface Indexable {
    $file?: string;
    $id: string;
    $parent?: Indexable;
    $revision?: number;
    $typename: string;
    $types: string[];
}

// @public
export const INDEXABLE_EXTENSIONS: Set<string>;

// @public
export interface IndexAnd {
    // (undocumented)
    elements: IndexQuery[];
    // (undocumented)
    type: "and";
}

// @public
export interface IndexChildOf {
    inclusive?: boolean;
    parents: IndexQuery;
    // (undocumented)
    type: "child-of";
}

// @public
export type IndexCombinator = IndexAnd | IndexOr | IndexNot;

// @public
export type IndexComparison = "=" | "!=" | ">" | "<" | ">=" | "<=";

// @public
export interface IndexConstant {
    // (undocumented)
    constant: boolean;
    // (undocumented)
    type: "constant";
}

// @public
export interface IndexExpression {
    expression: Expression;
    // (undocumented)
    type: "expression";
}

// @public
export interface IndexField {
    // (undocumented)
    type: "field";
    value: string;
}

// @public
export interface IndexId {
    // (undocumented)
    type: "id";
    value: string;
}

// @public
export type IndexIntermediate = IndexChildOf | IndexParentOf | IndexLinked;

// @public
export interface IndexLink {
    // (undocumented)
    type: "link";
    value: Link;
}

// @public
export interface IndexLinked {
    direction: "outgoing" | "incoming" | "both";
    distance?: number;
    inclusive?: boolean;
    source: IndexQuery;
    // (undocumented)
    type: "linked";
}

// @public
export interface IndexNot {
    // (undocumented)
    element: IndexQuery;
    // (undocumented)
    type: "not";
}

// @public
export interface IndexOr {
    // (undocumented)
    elements: IndexQuery[];
    // (undocumented)
    type: "or";
}

// @public
export interface IndexParentOf {
    children: IndexQuery;
    inclusive?: boolean;
    // (undocumented)
    type: "parent-of";
}

// @public
export interface IndexPath {
    exact?: boolean;
    // (undocumented)
    type: "path";
    value: string;
}

// @public
export type IndexPrimitive = IndexId | IndexLink | IndexConstant | IndexTyped | IndexTagged | IndexPath | IndexField | IndexValueEquals;

// @public
export type IndexQuery = IndexCombinator | IndexExpression | IndexSource;

// @public
export type IndexSource = IndexIntermediate | IndexPrimitive;

// @public
export interface IndexTagged {
    exact?: boolean;
    // (undocumented)
    type: "tagged";
    value: string;
}

// @public
export interface IndexTyped {
    // (undocumented)
    type: "typed";
    value: string;
}

// @public
export interface IndexValueEquals {
    field: string;
    // (undocumented)
    type: "equal-value";
    values: Literal[];
}

// @public
export type Ingrouped<U, T> = T extends {
    key: any;
    rows: any;
} ? {
    key: T["key"];
    rows: Ingrouped<U, T["rows"][0]>;
} : {
    key: U;
    rows: T[];
};

// Warning: (ae-forgotten-export) The symbol "JsonFrontmatterEntry" needs to be exported by the entry point index.d.ts
//
// @public
export function jsonFrontmatterEntry(raw: FrontmatterEntry): JsonFrontmatterEntry;

// @public
export class Link {
    static block(path: string, blockId: string, embed?: boolean, display?: string): Link;
    display?: string;
    displayOrDefault(): string;
    embed: boolean;
    equals(other: Link): boolean;
    static file(path: string, embed?: boolean, display?: string): Link;
    fileName(): string;
    fromEmbed(): Link;
    // Warning: (ae-forgotten-export) The symbol "JsonLink" needs to be exported by the entry point index.d.ts
    static fromObject(object: JsonLink): Link;
    static header(path: string, header: string, embed?: boolean, display?: string): Link;
    static infer(linkpath: string, embed?: boolean, display?: string): Link;
    markdown(): string;
    obsidianLink(): string;
    static parseInner(rawlink: string): Link;
    path: string;
    subpath?: string;
    toEmbed(): Link;
    toFile(): Link;
    toObject(): JsonLink;
    toString(): string;
    type: "file" | "header" | "block";
    withBlock(block: string): Link;
    withDisplay(display?: string): Link;
    withEmbed(embed: boolean): Link;
    withHeader(header: string): Link;
    withPath(path: string): Link;
}

// @public
export interface Linkable {
    $link: Link;
}

// @public
export const LINKABLE_TYPE = "linkable";

// @public
export interface Linkbearing {
    $links: Link[];
}

// @public
export const LINKBEARING_TYPE = "links";

// @public
export type LinkNormalizer = (link: Link) => Link;

// @public
export type Literal = boolean | number | string | DateTime | Duration | Link | Array<Literal> | DataObject | Function | null;

// @public
export type LiteralRepr<T extends LiteralType> = T extends "boolean" ? boolean : T extends "number" ? number : T extends "string" ? string : T extends "duration" ? Duration : T extends "date" ? DateTime : T extends "null" ? null : T extends "link" ? Link : T extends "array" ? Array<Literal> : T extends "object" ? DataObject : T extends "function" ? Function : any;

// @public
export namespace Literals {
    export function compare(val1: Literal | undefined, val2: Literal | undefined, linkNormalizer?: (link: string) => string): number;
    const DEFAULT_TO_STRING: ToStringSettings;
    export function deepCopy<T extends Literal>(field: T): T;
    export function equals(first: Literal | undefined, second: Literal | undefined): boolean;
    export function isArray(val: any): val is any[];
    export function isBoolean(val: any): val is boolean;
    export function isDate(val: any): val is DateTime;
    export function isDuration(val: any): val is Duration;
    export function isFunction(val: any): val is Function;
    export function isLink(val: any): val is Link;
    export function isNull(val: any): val is null | undefined;
    export function isNumber(val: any): val is number;
    export function isObject(val: any): val is Record<string, any>;
    export function isString(val: any): val is string;
    export function isTruthy(field: Literal): boolean;
    export function mapLeaves(val: Literal, func: (t: Literal) => Literal): Literal;
    export function toString(field: any, setting?: ToStringSettings, recursive?: boolean): string;
    export interface ToStringSettings {
        dateFormat: string;
        dateTimeFormat: string;
        nullRepresentation: string;
    }
    export function typeOf(val: any): LiteralType | undefined;
    export function wrapValue(val: Literal): WrappedLiteral | undefined;
}

// @public
export type LiteralType = "boolean" | "number" | "string" | "date" | "duration" | "link" | "array" | "object" | "function" | "null";

// @public
export interface LiteralWrapper<T extends LiteralType> {
    // (undocumented)
    type: T;
    // (undocumented)
    value: LiteralRepr<T>;
}

// @public
export type LowestKey<T> = T extends {
    key: any;
    rows: any;
} ? LowestKey<T["rows"][0]> : T;

// @public
export class MarkdownBlock implements Indexable, Linkbearing, Taggable, Fieldbearing {
    $blockId?: string;
    // (undocumented)
    $file: string;
    // (undocumented)
    $id: string;
    $infields: Record<string, InlineField>;
    get $link(): Link | undefined;
    $links: Link[];
    $ordinal: number;
    // Warning: (ae-forgotten-export) The symbol "LineSpan" needs to be exported by the entry point index.d.ts
    $position: LineSpan;
    $tags: string[];
    $type: string;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    protected constructor(init: Partial<MarkdownBlock>);
    field(key: string): Field;
    // (undocumented)
    static FIELD_DEF: FieldExtractor<MarkdownBlock>;
    get fields(): Field[];
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownBlock" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static from(object: JsonMarkdownBlock, file: string, normalizer?: LinkNormalizer): MarkdownBlock;
    // (undocumented)
    json(): JsonMarkdownBlock;
    static readableId(file: string, ordinal: number): string;
    // (undocumented)
    static TYPES: string[];
    // (undocumented)
    value(key: string): Literal | undefined;
}

// @public
export class MarkdownCodeblock extends MarkdownBlock implements Indexable, Fieldbearing, Linkbearing {
    // (undocumented)
    $contentPosition: {
        start: number;
        end: number;
    };
    // (undocumented)
    $languages: string[];
    // (undocumented)
    $style: "fenced" | "indent";
    // (undocumented)
    $types: string[];
    constructor(init: Partial<MarkdownCodeblock>);
    field(key: string): Field;
    get fields(): Field[];
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownCodeblock" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static from(object: JsonMarkdownCodeblock, file: string, normalizer?: LinkNormalizer): MarkdownCodeblock;
    // (undocumented)
    json(): JsonMarkdownCodeblock;
    // (undocumented)
    static readableId(file: string, line: number): string;
    // (undocumented)
    static SUB_FIELD_DEF: FieldExtractor<MarkdownCodeblock>;
    // (undocumented)
    static TYPES: string[];
    // (undocumented)
    value(key: string): Literal | undefined;
}

// @public
export class MarkdownDatablock extends MarkdownBlock implements Indexable, Fieldbearing, Linkbearing {
    // (undocumented)
    $data: Record<string, FrontmatterEntry>;
    // (undocumented)
    $types: string[];
    constructor(init: Partial<MarkdownDatablock>);
    field(key: string): Field;
    get fields(): Field[];
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownDatablock" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static from(object: JsonMarkdownDatablock, file: string, normalizer?: LinkNormalizer): MarkdownDatablock;
    // (undocumented)
    json(): JsonMarkdownDatablock;
    // (undocumented)
    static readableId(file: string, line: number): string;
    // (undocumented)
    static SUB_FIELD_DEF: FieldExtractor<MarkdownDatablock>;
    // (undocumented)
    static TYPES: string[];
    // (undocumented)
    value(key: string): Literal | undefined;
}

// @public
export class MarkdownListBlock extends MarkdownBlock implements Taggable, Linkbearing {
    $elements: MarkdownListItem[];
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    constructor(init: Partial<MarkdownListBlock>);
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownListBlock" needs to be exported by the entry point index.d.ts
    static from(object: JsonMarkdownListBlock, file: string, normalizer?: LinkNormalizer): MarkdownListBlock;
    // (undocumented)
    json(): JsonMarkdownListBlock;
    // (undocumented)
    static TYPES: string[];
}

// @public
export class MarkdownListItem implements Indexable, Linkbearing, Taggable, Fieldbearing {
    $blockId?: string;
    get $cleantext(): string;
    $elements: MarkdownListItem[];
    // (undocumented)
    $file: string;
    // (undocumented)
    $id: string;
    $infields: Record<string, InlineField>;
    get $line(): number;
    get $lineCount(): number;
    $links: Link[];
    $parentLine: number;
    $position: LineSpan;
    $symbol?: string;
    $tags: string[];
    $text?: string;
    $type: string;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    protected constructor(init: Partial<MarkdownListItem>);
    field(key: string): Field;
    get fields(): Field[];
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownListItem" needs to be exported by the entry point index.d.ts
    static from(object: JsonMarkdownListItem, file: string, normalizer?: LinkNormalizer): MarkdownListItem;
    // (undocumented)
    json(): JsonMarkdownListItem;
    static readableId(file: string, line: number): string;
    // (undocumented)
    static TYPES: string[];
    // (undocumented)
    value(key: string): Literal | undefined;
}

// @public
export class MarkdownPage implements File_2, Linkbearing, Taggable, Indexable, Fieldbearing {
    $ctime: DateTime;
    $extension: string;
    // (undocumented)
    get $file(): string;
    $frontmatter?: Record<string, FrontmatterEntry>;
    // (undocumented)
    get $id(): string;
    $infields: Record<string, InlineField>;
    get $lineCount(): number;
    get $link(): Link;
    $links: Link[];
    $mtime: DateTime;
    get $name(): string;
    $path: string;
    $position: LineSpan;
    $sections: MarkdownSection[];
    $size: number;
    $tags: string[];
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    field(key: string): Field | undefined;
    get fields(): Field[];
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownPage" needs to be exported by the entry point index.d.ts
    static from(raw: JsonMarkdownPage, normalizer?: LinkNormalizer): MarkdownPage;
    json(): JsonMarkdownPage;
    static TYPES: string[];
    value(key: string): Literal | undefined;
}

// @public (undocumented)
export class MarkdownSection implements Indexable, Taggable, Linkable, Linkbearing, Fieldbearing {
    $blocks: MarkdownBlock[];
    // (undocumented)
    $file: string;
    // (undocumented)
    $id: string;
    $infields: Record<string, InlineField>;
    $level: number;
    get $lineCount(): number;
    get $link(): Link;
    $links: Link[];
    get $name(): string;
    $ordinal: number;
    $position: LineSpan;
    $tags: string[];
    $title: string;
    // (undocumented)
    $typename: string;
    $types: string[];
    field(key: string): Field;
    get fields(): Field[];
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownSection" needs to be exported by the entry point index.d.ts
    static from(raw: JsonMarkdownSection, file: string, normalizer?: LinkNormalizer): MarkdownSection;
    // (undocumented)
    json(): JsonMarkdownSection;
    static readableId(file: string, title: string, ordinal: number): string;
    static TYPES: string[];
    // (undocumented)
    value(key: string): Literal | undefined;
}

// @public
export class MarkdownTaskItem extends MarkdownListItem implements Indexable, Linkbearing, Taggable, Fieldbearing {
    get $completed(): boolean;
    $status: string;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    constructor(init: Partial<MarkdownTaskItem>);
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownTaskItem" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static from(object: JsonMarkdownTaskItem, file: string, normalizer: LinkNormalizer): MarkdownTaskItem;
    // (undocumented)
    json(): JsonMarkdownListItem;
    // (undocumented)
    static TYPES: string[];
}

// @public (undocumented)
export const NOOP_NORMALIZER: LinkNormalizer;

// @public
export function normalizeLinks<T extends Literal>(input: T, normalizer: LinkNormalizer): T;

// @public
export type Provenance = {
    type: "frontmatter";
    file: string;
    key: string;
} | {
    type: "inline-field";
    file: string;
    line: number;
    key: string;
};

// @public
export type Result<T, E> = Success<T, E> | Failure<T, E>;

// @public
export namespace Result {
    export function async<T>(promise: Promise<T>): Promise<Result<T, Error>>;
    export function failure<T, E>(error: E): Result<T, E>;
    export function flatMap2<T1, T2, O, E>(first: Result<T1, E>, second: Result<T2, E>, f: (a: T1, b: T2) => Result<O, E>): Result<O, E>;
    export function map2<T1, T2, O, E>(first: Result<T1, E>, second: Result<T2, E>, f: (a: T1, b: T2) => O): Result<O, E>;
    export function mapAll<T, O, E>(input: Iterable<T>, func: (input: T) => Result<O, E>): Result<O[], E>;
    export function success<T, E>(value: T): Result<T, E>;
    export function trying<T>(call: () => T): Result<T, Error>;
}

// @public
export interface Settings {
    defaultDateFormat: string;
    defaultDateTimeFormat: string;
    defaultPageSize: number;
    defaultPagingEnabled: boolean;
    enableJs: boolean;
    importerNumThreads: number;
    importerUtilization: number;
    indexInlineFields: boolean;
    indexListItems: boolean;
    maxRecursiveRenderDepth: number;
    renderNullAs: string;
    scrollOnPageChange: boolean;
}

// @public
export class Success<T, E> {
    constructor(value: T);
    // (undocumented)
    bimap<T2, E2>(succ: (a: T) => T2, _fail: (b: E) => E2): Result<T2, E2>;
    // (undocumented)
    cast<U>(): Result<U, E>;
    // (undocumented)
    flatMap<U>(f: (a: T) => Result<U, E>): Result<U, E>;
    // (undocumented)
    map<U>(f: (a: T) => U): Result<U, E>;
    // (undocumented)
    mapErr<U>(f: (e: E) => U): Result<T, U>;
    // (undocumented)
    orElse(_value: T): T;
    // (undocumented)
    orElseThrow(_message?: (e: E) => string): T;
    // (undocumented)
    successful: true;
    // (undocumented)
    value: T;
}

// @public
export interface Taggable {
    $tags: string[];
}

// @public
export const TAGGABLE_TYPE = "taggable";

// @public
export function valueFrontmatterEntry(raw: JsonFrontmatterEntry): FrontmatterEntry;

// @public
export type WrappedLiteral = LiteralWrapper<"string"> | LiteralWrapper<"number"> | LiteralWrapper<"boolean"> | LiteralWrapper<"date"> | LiteralWrapper<"duration"> | LiteralWrapper<"link"> | LiteralWrapper<"array"> | LiteralWrapper<"object"> | LiteralWrapper<"function"> | LiteralWrapper<"null">;

// (No @packageDocumentation comment for this package)

```
