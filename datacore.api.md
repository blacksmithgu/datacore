## API Report File for "@blacksmithgu/datacore"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { App } from 'obsidian';
import { Component } from 'obsidian';
import { ComponentChildren } from 'preact';
import { CSSProperties } from 'preact/compat';
import { DateTime } from 'luxon';
import { Duration } from 'luxon';
import { EventRef } from 'obsidian';
import { Events } from 'obsidian';
import { FileManager } from 'obsidian';
import * as hooks from 'preact/hooks';
import { HTMLAttributes } from 'preact/compat';
import { JSX } from 'preact/compat';
import { JSX as JSX_2 } from 'preact/jsx-runtime';
import { JSX as JSX_3 } from 'preact';
import * as luxon_2 from 'luxon';
import { MarkdownPostProcessorContext } from 'obsidian';
import { MarkdownRenderChild } from 'obsidian';
import { MetadataCache } from 'obsidian';
import { Plugin as Plugin_2 } from 'obsidian';
import * as preact_2 from 'preact';
import { PropsWithChildren } from 'preact/compat';
import { Queue } from '@datastructures-js/queue';
import { default as React_2 } from 'preact/compat';
import { ReactNode } from 'preact/compat';
import { TFile } from 'obsidian';
import { Vault } from 'obsidian';
import { VNode } from 'preact';

// @public
export type ArithmeticOp = "+" | "-" | "*" | "/" | "%" | "&" | "|";

// @public
export type ArrayComparator<T> = (a: T, b: T) => number;

// @public
export type ArrayFunc<T, O> = (elem: T, index: number, arr: T[]) => O;

// @public
export abstract class BaseCanvasCard implements Indexable, Linkable {
    // (undocumented)
    $color?: string;
    // (undocumented)
    $dimensions: CardDimensions;
    // (undocumented)
    $file: string;
    // (undocumented)
    $id: string;
    // (undocumented)
    get $link(): Link;
    // (undocumented)
    $parent?: Indexable;
    // (undocumented)
    $position: CardPos;
    // (undocumented)
    $revision?: number | undefined;
    // (undocumented)
    abstract readonly $type: string;
    // (undocumented)
    abstract $typename: string;
    // (undocumented)
    abstract $types: string[];
    constructor(init: Partial<BaseCanvasCard>);
    // Warning: (ae-forgotten-export) The symbol "JsonBaseCanvasCard" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    json(): JsonBaseCanvasCard;
}

// @public
export type BinaryOp = CompareOp | ArithmeticOp | LogicalOp;

// @public
export interface BinaryOpExpression {
    // (undocumented)
    left: Expression;
    // (undocumented)
    op: BinaryOp;
    // (undocumented)
    right: Expression;
    // (undocumented)
    type: "binaryop";
}

// @public
export function Button(props: {
    className?: string;
    intent?: Intent;
    children: ComponentChildren;
} & React_2.ComponentProps<"button">): React_2.JSX.Element;

// @public
export function Callout({ collapsible, open: openProp, initialOpen, onOpenChange, title, icon, children, type, }: PropsWithChildren<CalloutProps>): JSX_3.Element;

// @public
export interface CalloutProps {
    collapsible?: boolean;
    icon?: VNode;
    initialOpen?: boolean;
    onOpenChange?: (value: boolean) => void;
    open: boolean;
    title: string | VNode;
    type?: string;
}

// @public
export class Canvas implements Linkable, File_2, Linkbearing, Taggable, Indexable, Fieldbearing {
    // (undocumented)
    $cards: BaseCanvasCard[];
    $ctime: DateTime;
    $extension: string;
    get $file(): string;
    // (undocumented)
    get $id(): string;
    // (undocumented)
    $infields: Record<string, InlineField>;
    get $link(): Link;
    // (undocumented)
    $links: Link[];
    $mtime: DateTime;
    // (undocumented)
    $path: string;
    // (undocumented)
    $size: number;
    // (undocumented)
    $tags: string[];
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    // (undocumented)
    field(key: string): Field | undefined;
    // (undocumented)
    get fields(): Field[];
    // Warning: (ae-incompatible-release-tags) The symbol "from" is marked as @public, but its signature references "LinkNormalizer" which is marked as @internal
    //
    // (undocumented)
    static from(raw: JsonCanvas, normalizer?: LinkNormalizer): Canvas;
    // Warning: (ae-forgotten-export) The symbol "JsonCanvas" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    json(): JsonCanvas;
    // (undocumented)
    static TYPES: string[];
}

// @public
export type CanvasCard = CanvasTextCard | CanvasFileCard | CanvasWebCard;

// @public
export class CanvasFileCard extends BaseCanvasCard implements Indexable {
    // (undocumented)
    $linkedFile: string;
    // (undocumented)
    readonly $type: string;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    // @internal (undocumented)
    static from(raw: JsonCanvasFileCard): CanvasFileCard;
    // Warning: (ae-forgotten-export) The symbol "JsonCanvasFileCard" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    json(): JsonCanvasFileCard;
    // (undocumented)
    static TYPES: string[];
}

// @public
export class CanvasTextCard extends BaseCanvasCard implements Linkbearing, Taggable, Indexable, Fieldbearing {
    // (undocumented)
    $dimensions: CardDimensions;
    // (undocumented)
    $file: string;
    // (undocumented)
    $frontmatter?: Record<string, FrontmatterEntry>;
    // (undocumented)
    $id: string;
    // (undocumented)
    $infields: Record<string, InlineField>;
    // (undocumented)
    $links: Link[];
    // (undocumented)
    $parent?: Indexable;
    // (undocumented)
    $revision?: number;
    // (undocumented)
    $sections: MarkdownSection[];
    // (undocumented)
    $tags: string[];
    // (undocumented)
    $title: string;
    // (undocumented)
    $type: string;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    // (undocumented)
    field(key: string): Field | undefined;
    // (undocumented)
    static FIELD_DEF: FieldExtractor<CanvasTextCard>;
    // (undocumented)
    get fields(): Field[];
    // @internal (undocumented)
    static from(raw: JsonCanvasTextCard, file: string, normalizer?: LinkNormalizer): CanvasTextCard;
    // Warning: (ae-forgotten-export) The symbol "JsonCanvasTextCard" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    json(): JsonCanvasTextCard;
    // (undocumented)
    static TYPES: string[];
}

// @public (undocumented)
export class CanvasWebCard extends BaseCanvasCard implements Indexable {
    // (undocumented)
    readonly $type: string;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    // (undocumented)
    $url: string;
    // @internal (undocumented)
    static from(raw: JsonCanvasWebCard, file: string): CanvasWebCard;
    // Warning: (ae-forgotten-export) The symbol "JsonCanvasWebCard" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    json(): JsonCanvasWebCard;
    // (undocumented)
    static TYPES: string[];
}

// @public
export function Card<T>(props: CardProps<T>): JSX_3.Element;

// @public
export interface CardDimensions {
    // (undocumented)
    height: number;
    // (undocumented)
    width: number;
}

// @public
export interface CardPos {
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public
export interface CardProps<T> {
    centerTitle?: boolean;
    content: Literal | ((val: T) => Literal | VNode);
    footer?: Literal | ((val: T) => Literal | VNode);
    title: Literal | ((val: T) => Literal | VNode);
    value: T;
}

// @public
export function Checkbox(props: {
    className?: string;
    disabled?: boolean;
    checked?: boolean;
    defaultChecked?: boolean;
    onCheckChange?: (checked: boolean) => void;
    children?: ComponentChildren;
} & React_2.ComponentProps<"input">): React_2.JSX.Element;

// Warning: (ae-internal-missing-underscore) The name "combineClasses" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function combineClasses(fixed: string, ...rest: (string | undefined)[]): string;

// @public
export type CompareOp = ">" | ">=" | "<=" | "<" | "=" | "!=";

// @public
export interface DataArray<T> {
    [Symbol.iterator](): Iterator<T>;
    [index: number]: T;
    array(): T[];
    chain<U>(op: (arr: DataArray<T>) => DataArray<U>): DataArray<U>;
    concat(other: Iterable<T>): DataArray<T>;
    distinct<U>(key?: ArrayFunc<T, U>, comparator?: ArrayComparator<U>): DataArray<T>;
    every(f: ArrayFunc<T, boolean>): boolean;
    expand(key: string): DataArray<unknown>;
    filter(predicate: ArrayFunc<T, boolean>): DataArray<T>;
    find(pred: ArrayFunc<T, boolean>): T | undefined;
    findIndex(pred: ArrayFunc<T, boolean>, fromIndex?: number): number;
    first(): T | undefined;
    flatMap<U>(f: ArrayFunc<T, U[]>): DataArray<U>;
    forEach(f: ArrayFunc<T, void>): void;
    groupBy<U>(key: ArrayFunc<T, U>, comparator?: ArrayComparator<U>): DataArray<{
        key: U;
        rows: T[];
    }>;
    groupIn<U>(key: ArrayFunc<LowestKey<T>, U>, comparator?: ArrayComparator<U>): DataArray<Ingrouped<U, T>>;
    includes(element: T): boolean;
    indexOf(element: T, fromIndex?: number): number;
    into(key: string): DataArray<unknown>;
    join(sep?: string): string;
    last(): T | undefined;
    length: number;
    limit(count: number): DataArray<T>;
    map<U>(f: ArrayFunc<T, U>): DataArray<U>;
    mutate(f: ArrayFunc<T, void>): DataArray<T>;
    none(f: ArrayFunc<T, boolean>): boolean;
    slice(start?: number, end?: number): DataArray<T>;
    some(f: ArrayFunc<T, boolean>): boolean;
    sort<U>(key: ArrayFunc<T, U>, direction?: "asc" | "desc", comparator?: ArrayComparator<U>): DataArray<T>;
    sortInPlace<U>(key: (v: T) => U, direction?: "asc" | "desc", comparator?: ArrayComparator<U>): DataArray<T>;
    to(key: string): DataArray<unknown>;
    where(predicate: ArrayFunc<T, boolean>): DataArray<T>;
}

// @public
export namespace DataArray {
    export function defaultComparator(first: unknown, second: unknown): number;
    export function from<T>(raw: Iterable<T>): DataArray<T>;
    export function isDataArray(obj: unknown): obj is DataArray<unknown>;
    export function wrap<T>(raw: T[] | DataArray<T>): DataArray<T>;
}

// @public
export class Datacore extends Component {
    // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @public, but its signature references "Settings" which is marked as @internal
    constructor(app: App, version: string, settings: Settings);
    // (undocumented)
    app: App;
    // @internal
    datastore: Datastore;
    events: Events;
    // Warning: (ae-forgotten-export) The symbol "FileImporter" needs to be exported by the entry point index.d.ts
    //
    // @internal
    importer: FileImporter;
    index(): Promise<void>;
    initialize(): void;
    initialized: boolean;
    // Warning: (ae-forgotten-export) The symbol "DatacoreInitializer" needs to be exported by the entry point index.d.ts
    //
    // @internal
    initializer?: DatacoreInitializer;
    metadataCache: MetadataCache;
    off(evt: string, callback: (...data: unknown[]) => void): void;
    offref(ref: EventRef): void;
    on(evt: "update", callback: (revision: number) => void, context?: unknown): EventRef;
    on(evt: "rename", callback: (newPath: string, oldPath: string) => void, context?: unknown): EventRef;
    on(evt: "initialized", callback: () => void, context?: unknown): EventRef;
    // Warning: (ae-forgotten-export) The symbol "LocalStorageCache" needs to be exported by the entry point index.d.ts
    //
    // @internal
    persister: LocalStorageCache;
    read(file: TFile): Promise<string>;
    // Warning: (ae-forgotten-export) The symbol "EmbedQueue" needs to be exported by the entry point index.d.ts
    //
    // @internal
    reads: EmbedQueue;
    reindex(): Promise<void>;
    reload(file: TFile): Promise<Indexable>;
    get revision(): number;
    // Warning: (ae-incompatible-release-tags) The symbol "settings" is marked as @public, but its signature references "Settings" which is marked as @internal
    //
    // (undocumented)
    settings: Settings;
    storeCanvas(data: Canvas): void;
    storeMarkdown(data: MarkdownPage): void;
    vault: Vault;
    // (undocumented)
    version: string;
}

// @public
export class DatacoreApi {
    constructor(core: Datacore);
    get app(): App;
    array<T>(input: T[] | DataArray<T>): DataArray<T>;
    blockLink(path: string, block: string): Link;
    // Warning: (ae-forgotten-export) The symbol "Coerce" needs to be exported by the entry point index.d.ts
    coerce: typeof Coerce;
    // (undocumented)
    core: Datacore;
    evaluate(expression: string | Expression, variables?: Record<string, Literal>, sourcePath?: string): Literal;
    executeJs(source: string, container: HTMLElement, component: Component | MarkdownPostProcessorContext, sourcePath: string): MarkdownRenderChild;
    executeJsx(source: string, container: HTMLElement, component: Component | MarkdownPostProcessorContext, sourcePath: string): MarkdownRenderChild;
    executeTs(source: string, container: HTMLElement, component: Component | MarkdownPostProcessorContext, sourcePath: string): MarkdownRenderChild;
    executeTsx(source: string, container: HTMLElement, component: Component | MarkdownPostProcessorContext, sourcePath: string): MarkdownRenderChild;
    fileLink(path: string): Link;
    fullquery(query: string | IndexQuery): SearchResult<Indexable>;
    headerLink(path: string, header: string): Link;
    local(path: string): DatacoreLocalApi;
    get luxon(): typeof luxon_2;
    page(path: string | Link): MarkdownPage | undefined;
    parseLink(linktext: string): Link;
    parseQuery(query: string | IndexQuery): IndexQuery;
    get preact(): typeof preact_2;
    query(query: string | IndexQuery): Indexable[];
    resolvePath(path: string | Link, sourcePath?: string): string;
    tryEvaluate(expression: string | Expression, variables?: Record<string, Literal>, sourcePath?: string): Result<Literal, string>;
    tryFullQuery(query: string | IndexQuery): Result<SearchResult<Indexable>, string>;
    tryParseLink(linktext: string): Result<Link, string>;
    tryParseQuery(query: string | IndexQuery): Result<IndexQuery, string>;
    tryQuery(query: string | IndexQuery): Result<Indexable[], string>;
}

// @public
export class DatacoreLocalApi {
    constructor(api: DatacoreApi, path: string);
    // (undocumented)
    api: DatacoreApi;
    get app(): App;
    array<T>(input: T[] | DataArray<T>): DataArray<T>;
    blockLink(path: string, block: string): Link;
    // (undocumented)
    Button: typeof Button;
    // (undocumented)
    Callout: typeof Callout;
    Card: typeof Card;
    // (undocumented)
    Checkbox: typeof Checkbox;
    coerce: typeof Coerce;
    get core(): Datacore;
    createContext: typeof preact_2.createContext;
    currentFile(): MarkdownPage;
    currentPath(): string;
    embed: any;
    evaluate(expression: string | Expression, variables?: Record<string, Literal>, sourcePath?: string): Literal;
    fileLink(path: string): Link;
    fullquery(query: string | IndexQuery): SearchResult<Indexable>;
    Group: typeof Group;
    headerLink(path: string, header: string): Link;
    Icon: typeof Icon;
    Link: ({ link, sourcePath: maybeSourcePath }: {
        link: Link | string;
        sourcePath?: string;
    }) => preact_2.JSX.Element;
    LinkEmbed: any;
    List: typeof ListView;
    Literal: any;
    get luxon(): typeof luxon_2;
    Markdown: any;
    parseLink(linktext: string): Link;
    parseQuery(query: string | IndexQuery): IndexQuery;
    // (undocumented)
    path: string;
    get preact(): typeof preact_2;
    query(query: string | IndexQuery): Indexable[];
    require(path: string | Link): Promise<unknown>;
    resolvePath(path: string | Link, sourcePath?: string): string;
    // (undocumented)
    Slider: typeof Slider;
    SpanEmbed: any;
    Stack: typeof Stack;
    // (undocumented)
    Switch: typeof Switch;
    Table: typeof TableView;
    // (undocumented)
    Textbox: typeof Textbox;
    tryEvaluate(expression: string | Expression, variables?: Record<string, Literal>, sourcePath?: string): Result<Literal, string>;
    tryFullQuery(query: string | IndexQuery): Result<SearchResult<Indexable>, string>;
    tryParseLink(linktext: string): Result<Link, string>;
    tryParseQuery(query: string | IndexQuery): Result<IndexQuery, string>;
    tryQuery(query: string | IndexQuery): Result<Indexable[], string>;
    useArray<T, U>(input: T[] | DataArray<T>, process: (data: DataArray<T>) => DataArray<U>, deps?: unknown[]): U[];
    useCallback: typeof hooks.useCallback;
    useContext: typeof hooks.useContext;
    useCurrentFile(settings?: {
        debounce?: number;
    }): MarkdownPage;
    useCurrentPath(settings?: {
        debounce?: number;
    }): string;
    useEffect: typeof hooks.useEffect;
    useFile(path: string, settings?: {
        debounce?: number;
    }): Indexable | undefined;
    useFullQuery(query: string | IndexQuery, settings?: {
        debounce?: number;
    }): SearchResult<Indexable>;
    useIndexUpdates(settings?: {
        debounce?: number;
    }): number;
    // Warning: (ae-forgotten-export) The symbol "useInterning" needs to be exported by the entry point index.d.ts
    useInterning: typeof useInterning;
    useMemo: typeof hooks.useMemo;
    useQuery(query: string | IndexQuery, settings?: {
        debounce?: number;
    }): Indexable[];
    useReducer: typeof hooks.useReducer;
    useRef: typeof hooks.useRef;
    useState: typeof hooks.useState;
    // (undocumented)
    VanillaSelect: typeof VanillaSelect;
    // @deprecated (undocumented)
    VanillaTable: typeof TableView;
}

// Warning: (ae-internal-missing-underscore) The name "DatacorePlugin" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class DatacorePlugin extends Plugin_2 {
    api: DatacoreApi;
    core: Datacore;
    // (undocumented)
    onload(): Promise<void>;
    registerCodeblockHighlighting(): () => void;
    settings: Settings;
    updateSettings(settings: Partial<Settings>): Promise<void>;
}

// @public
export interface DataObject {
    // (undocumented)
    [key: string]: Literal;
}

// Warning: (ae-internal-missing-underscore) The name "Datastore" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class Datastore {
    constructor(vault: Vault, metadataCache: MetadataCache, settings: Settings);
    clear(): void;
    delete(id: string): boolean;
    // Warning: (ae-forgotten-export) The symbol "Evaluator" needs to be exported by the entry point index.d.ts
    evaluator(sourcePath?: string, globals?: Record<string, Literal>): Evaluator;
    load(id: string): Indexable | undefined;
    load(ids: string[]): Indexable[];
    // (undocumented)
    metadataCache: MetadataCache;
    resolveLink(rawLink: string | Link, sourcePath?: string): Indexable | undefined;
    revision: number;
    // Warning: (ae-forgotten-export) The symbol "SearchSettings" needs to be exported by the entry point index.d.ts
    search(query: IndexQuery, settings?: SearchSettings): Result<SearchResult<Indexable>, string>;
    // (undocumented)
    settings: Settings;
    get size(): number;
    // Warning: (ae-forgotten-export) The symbol "Substorer" needs to be exported by the entry point index.d.ts
    store<T extends Indexable>(object: T | T[], substorer?: Substorer<T>): void;
    touch(): void;
    // (undocumented)
    vault: Vault;
}

// @public (undocumented)
export type Expression = LiteralExpression | VariableExpression | ListExpression | ObjectExpression | BinaryOpExpression | FunctionExpression | MethodExpression | LambdaExpression | NegatedExpression;

// @public (undocumented)
export namespace Expressions {
    const ROW: string;
    // (undocumented)
    export function binaryOp(left: Expression, op: BinaryOp, right: Expression): Expression;
    // (undocumented)
    export function func(func: Expression, args: Expression[]): FunctionExpression;
    // (undocumented)
    export function index(obj: Expression, index: Expression): Expression;
    export function indexVariable(name: string): Expression;
    // (undocumented)
    export function isCompareOp(op: BinaryOp): op is CompareOp;
    // (undocumented)
    export function lambda(args: string[], value: Expression): LambdaExpression;
    // (undocumented)
    export function list(values: Expression[]): ListExpression;
    // (undocumented)
    export function literal(value: Literal): LiteralExpression;
    // (undocumented)
    export function method(target: Expression, func: string, args: Expression[]): MethodExpression;
    // (undocumented)
    export function negate(child: Expression): NegatedExpression;
    // (undocumented)
    export function object(values: Record<string, Expression>): ObjectExpression;
    export function toString(expr: Expression): string;
    export function unboundVariables(expr: Expression, bound?: Set<string>): Set<string>;
    // (undocumented)
    export function variable(name: string): VariableExpression;
    const // (undocumented)
    NULL: LiteralExpression;
}

// @public
export namespace Extractors {
    export function frontmatter<T extends Indexable>(front: (object: T) => Record<string, FrontmatterEntry> | undefined): FieldExtractor<T>;
    export function inlineFields<T extends Indexable>(inlineMap: (object: T) => Record<string, InlineField> | undefined): FieldExtractor<T>;
    export function intrinsics<T extends Indexable>(except?: Set<string>): FieldExtractor<T>;
    export function merge<T extends Fieldbearing>(...extractors: FieldExtractor<T>[]): FieldExtractor<T>;
}

// @public
export class Failure<T, E> {
    constructor(error: E);
    // (undocumented)
    bimap<T2, E2>(_succ: (a: T) => T2, fail: (b: E) => E2): Result<T2, E2>;
    // (undocumented)
    cast<U>(): Result<U, E>;
    // (undocumented)
    castErr<U>(): Result<T, U>;
    // (undocumented)
    error: E;
    // (undocumented)
    flatMap<U>(_f: (a: T) => Result<U, E>): Result<U, E>;
    // (undocumented)
    map<U>(_f: (a: T) => U): Result<U, E>;
    // (undocumented)
    mapErr<U>(f: (e: E) => U): Result<T, U>;
    // (undocumented)
    orElse(value: T): T;
    // (undocumented)
    orElseThrow(message?: (e: E) => string): T;
    // (undocumented)
    successful: false;
}

// @public
export interface Field {
    key: string;
    provenance: Provenance;
    raw?: string;
    value: Literal;
}

// @public (undocumented)
export interface Fieldbearing {
    field(key: string): Field | undefined;
    fields: Field[];
}

// @public
export const FIELDBEARING_TYPE = "fields";

// @public (undocumented)
export namespace Fieldbearings {
    export function get(object: Fieldbearing | DataObject, key: string): Literal | undefined;
    // (undocumented)
    export function isFieldbearing(object: unknown): object is Fieldbearing;
}

// @public
export type FieldExtractor<T> = (object: T, key?: string) => Field[];

// @public
interface File_2 extends Linkable {
    $ctime: DateTime;
    $extension: string;
    $mtime: DateTime;
    $path: string;
    $size: number;
}
export { File_2 as File }

// @public
export const FILE_TYPE = "file";

// @public
export interface FrontmatterEntry {
    key: string;
    raw: string;
    value: Literal;
}

// @public
export interface FunctionExpression {
    arguments: Expression[];
    func: Expression;
    // (undocumented)
    type: "function";
}

// Warning: (ae-internal-missing-underscore) The name "gatherLinks" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function gatherLinks(input: unknown): Link[];

// Warning: (ae-internal-missing-underscore) The name "gatherTags" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function gatherTags(data: Record<string, FrontmatterEntry>): string[];

// @public
export class GenericFile implements File_2, Indexable, Fieldbearing, Linkable {
    $ctime: DateTime;
    $extension: string;
    get $file(): string;
    get $id(): string;
    get $link(): Link;
    $mtime: DateTime;
    // (undocumented)
    $path: string;
    $size: number;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    constructor(path: string, ctime: DateTime, mtime: DateTime, size: number);
    // (undocumented)
    field(key: string): Field;
    // (undocumented)
    get fields(): Field[];
    // (undocumented)
    static TYPES: string[];
    value(key: string): Literal | undefined;
}

// @public
export function Group(props: HTMLAttributes<HTMLDivElement> & {
    className?: string;
    justify?: string;
    align?: string;
    style?: string;
}): JSX.Element;

// @public
export type GroupElement<T> = {
    key: Literal;
    rows: Grouping<T>;
};

// @public
export type Grouping<T> = T[] | GroupElement<T>[];

// @public (undocumented)
export namespace Groupings {
    export function count<T>(elements: Grouping<T> | GroupElement<T>): number;
    export function isElementGroup<T>(entry: unknown): entry is GroupElement<T>;
    export function isGrouping<T>(entry: Grouping<T>): entry is GroupElement<T>[];
    export function isLeaf<T>(entry: Grouping<T>): entry is T[];
    export function slice<T>(elements: Grouping<T>, start: number, end: number): Grouping<T>;
}

// @public
export function Icon(props: {
    className?: string;
    icon: string;
}): React_2.JSX.Element;

// @public
export const INDEX_ALL: IndexQuery;

// @public
export const INDEX_NONE: IndexQuery;

// @public
export interface Indexable {
    $file?: string;
    $id: string;
    $parent?: Indexable;
    $revision?: number;
    $typename: string;
    $types: string[];
}

// @public
export const INDEXABLE_EXTENSIONS: Set<string>;

// @public
export interface IndexAnd {
    // (undocumented)
    elements: IndexQuery[];
    // (undocumented)
    type: "and";
}

// @public
export interface IndexChildOf {
    inclusive?: boolean;
    parents: IndexQuery;
    // (undocumented)
    type: "child-of";
}

// @public
export type IndexCombinator = IndexAnd | IndexOr | IndexNot;

// @public
export type IndexComparison = "=" | "!=" | ">" | "<" | ">=" | "<=";

// @public
export interface IndexConstant {
    // (undocumented)
    constant: boolean;
    // (undocumented)
    type: "constant";
}

// @public
export interface IndexExpression {
    expression: Expression;
    // (undocumented)
    type: "expression";
}

// @public
export interface IndexField {
    // (undocumented)
    type: "field";
    value: string;
}

// @public
export interface IndexId {
    // (undocumented)
    type: "id";
    value: string;
}

// @public
export type IndexIntermediate = IndexChildOf | IndexParentOf | IndexLinked;

// @public
export interface IndexLink {
    // (undocumented)
    type: "link";
    value: Link;
}

// @public
export interface IndexLinked {
    direction: "outgoing" | "incoming" | "both";
    distance?: number;
    inclusive?: boolean;
    source: IndexQuery;
    // (undocumented)
    type: "linked";
}

// @public
export interface IndexNot {
    // (undocumented)
    element: IndexQuery;
    // (undocumented)
    type: "not";
}

// @public
export interface IndexOr {
    // (undocumented)
    elements: IndexQuery[];
    // (undocumented)
    type: "or";
}

// @public
export interface IndexParentOf {
    children: IndexQuery;
    inclusive?: boolean;
    // (undocumented)
    type: "parent-of";
}

// @public
export interface IndexPath {
    exact?: boolean;
    // (undocumented)
    type: "path";
    value: string;
}

// @public
export type IndexPrimitive = IndexId | IndexLink | IndexConstant | IndexTyped | IndexTagged | IndexPath | IndexField | IndexValueEquals;

// @public
export type IndexQuery = IndexCombinator | IndexExpression | IndexSource;

// @public
export type IndexSource = IndexIntermediate | IndexPrimitive;

// @public
export interface IndexTagged {
    exact?: boolean;
    // (undocumented)
    type: "tagged";
    value: string;
}

// @public
export interface IndexTyped {
    // (undocumented)
    type: "typed";
    value: string;
}

// @public
export interface IndexValueEquals {
    field: string;
    // (undocumented)
    type: "equal-value";
    values: Literal[];
}

// @public
export type Ingrouped<U, T> = T extends {
    key: unknown;
    rows: unknown[];
} ? {
    key: T["key"];
    rows: Ingrouped<U, T["rows"][0]>;
} : {
    key: U;
    rows: T[];
};

// @public
export interface InlineField {
    key: string;
    position: {
        line: number;
        start: number;
        startValue: number;
        end: number;
    };
    raw: string;
    value: Literal;
    wrapping?: string;
}

// @public
export type Intent = "error" | "warn" | "info" | "success";

// Warning: (ae-internal-missing-underscore) The name "INTENT_CLASSES" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const INTENT_CLASSES: Record<Intent, string>;

// Warning: (ae-forgotten-export) The symbol "JsonFrontmatterEntry" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "jsonFrontmatterEntry" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function jsonFrontmatterEntry(raw: FrontmatterEntry): JsonFrontmatterEntry;

// @public
export interface LambdaExpression {
    arguments: string[];
    // (undocumented)
    type: "lambda";
    value: Expression;
}

// @public
export class Link {
    static block(path: string, blockId: string, embed?: boolean, display?: string): Link;
    display?: string;
    displayOrDefault(): string;
    embed: boolean;
    equals(other: Link): boolean;
    static file(path: string, embed?: boolean, display?: string): Link;
    fileName(): string;
    fromEmbed(): Link;
    // Warning: (ae-forgotten-export) The symbol "JsonLink" needs to be exported by the entry point index.d.ts
    static fromObject(object: JsonLink): Link;
    static header(path: string, header: string, embed?: boolean, display?: string): Link;
    static infer(linkpath: string, embed?: boolean, display?: string): Link;
    markdown(): string;
    obsidianLink(): string;
    static parseInner(rawlink: string): Link;
    path: string;
    subpath?: string;
    toEmbed(): Link;
    toFile(): Link;
    toObject(): JsonLink;
    toString(): string;
    type: "file" | "header" | "block";
    withBlock(block: string): Link;
    withDisplay(display?: string): Link;
    withEmbed(embed: boolean): Link;
    withHeader(header: string): Link;
    withPath(path: string): Link;
}

// @public
export interface Linkable {
    $link: Link;
}

// @public
export const LINKABLE_TYPE = "linkable";

// @public
export interface Linkbearing {
    $links: Link[];
}

// @public
export const LINKBEARING_TYPE = "links";

// Warning: (ae-internal-missing-underscore) The name "LinkNormalizer" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type LinkNormalizer = (link: Link) => Link;

// @public
export interface ListExpression {
    // (undocumented)
    type: "list";
    // (undocumented)
    values: Expression[];
}

// @public
export function ListView<T>(props: ListViewProps<T>): JSX_3.Element;

// @public
export interface ListViewProps<T> {
    childSource?: null | string | string[] | ((row: T) => T[]);
    // Warning: (ae-forgotten-export) The symbol "GroupingConfig_2" needs to be exported by the entry point index.d.ts
    groupings?: GroupingConfig_2<T> | GroupingConfig_2<T>[] | ((key: Literal, rows: Grouping<T>) => Literal | VNode);
    maxChildDepth?: number;
    paging?: boolean | number;
    renderer?: (row: T) => React.ReactNode | Literal;
    rows: Grouping<T>;
    scrollOnPaging?: boolean | number;
    type?: "ordered" | "unordered" | "block";
}

// @public
export type ListViewType = "ordered" | "unordered" | "block";

// Warning: (ae-forgotten-export) The symbol "RawLit" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "Lit" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const Lit: typeof RawLit;

// @public
export type Literal = boolean | number | string | DateTime | Duration | Link | Array<Literal> | DataObject | Function | null;

// @public
export interface LiteralExpression {
    // (undocumented)
    type: "literal";
    // (undocumented)
    value: Literal;
}

// @public
export type LiteralRepr<T extends LiteralType> = T extends "boolean" ? boolean : T extends "number" ? number : T extends "string" ? string : T extends "duration" ? Duration : T extends "date" ? DateTime : T extends "null" ? null : T extends "link" ? Link : T extends "array" ? Array<Literal> : T extends "object" ? DataObject : T extends "function" ? Function : unknown;

// @public
export namespace Literals {
    export function compare(val1: Literal | undefined, val2: Literal | undefined, linkNormalizer?: (link: string) => string): number;
    const DEFAULT_TO_STRING: ToStringSettings;
    export function deepCopy<T extends Literal>(field: T): T;
    export function equals(first: Literal | undefined, second: Literal | undefined): boolean;
    export function isArray(val: unknown): val is unknown[];
    export function isBoolean(val: unknown): val is boolean;
    export function isDate(val: unknown): val is DateTime;
    export function isDuration(val: unknown): val is Duration;
    export function isFunction(val: unknown): val is Function;
    export function isLink(val: unknown): val is Link;
    export function isNull(val: unknown): val is null | undefined;
    export function isNumber(val: unknown): val is number;
    export function isObject(val: unknown): val is DataObject;
    export function isString(val: unknown): val is string;
    export function isTruthy(field: Literal): boolean;
    export function mapLeaves(val: Literal, func: (t: Literal) => Literal): Literal;
    export function toString(field: unknown, setting?: ToStringSettings, recursive?: boolean): string;
    export interface ToStringSettings {
        dateFormat: string;
        dateTimeFormat: string;
        nullRepresentation: string;
    }
    export function typeOf(val: unknown): LiteralType | undefined;
    export function wrapValue(val: unknown): WrappedLiteral | undefined;
}

// @public
export type LiteralType = "boolean" | "number" | "string" | "date" | "duration" | "link" | "array" | "object" | "function" | "null";

// @public
export interface LiteralWrapper<T extends LiteralType> {
    // (undocumented)
    type: T;
    // (undocumented)
    value: LiteralRepr<T>;
}

// @public
export type LogicalOp = "index";

// @public
export type LowestKey<T> = T extends {
    key: unknown;
    rows: unknown[];
} ? LowestKey<T["rows"][0]> : T;

// Warning: (ae-forgotten-export) The symbol "RawMarkdown" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "Markdown" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const Markdown: typeof RawMarkdown;

// @public
export class MarkdownBlock implements Indexable, Linkbearing, Taggable, Fieldbearing {
    $blockId?: string;
    // (undocumented)
    $file: string;
    // (undocumented)
    $id: string;
    $infields: Record<string, InlineField>;
    get $link(): Link | undefined;
    $links: Link[];
    $ordinal: number;
    // Warning: (ae-forgotten-export) The symbol "LineSpan" needs to be exported by the entry point index.d.ts
    $position: LineSpan;
    $tags: string[];
    $type: string;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    protected constructor(init: Partial<MarkdownBlock>);
    field(key: string): Field;
    // (undocumented)
    static FIELD_DEF: FieldExtractor<MarkdownBlock>;
    get fields(): Field[];
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownBlock" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    static from(object: JsonMarkdownBlock, file: string, normalizer?: LinkNormalizer): MarkdownBlock;
    // @internal (undocumented)
    json(): JsonMarkdownBlock;
    static readableId(file: string, ordinal: number): string;
    // (undocumented)
    static TYPES: string[];
    // (undocumented)
    value(key: string): Literal | undefined;
}

// @public
export class MarkdownCodeblock extends MarkdownBlock implements Indexable, Fieldbearing, Linkbearing {
    // (undocumented)
    $contentPosition: {
        start: number;
        end: number;
    };
    // (undocumented)
    $languages: string[];
    // (undocumented)
    $style: "fenced" | "indent";
    // (undocumented)
    $types: string[];
    constructor(init: Partial<MarkdownCodeblock>);
    field(key: string): Field;
    get fields(): Field[];
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownCodeblock" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    static from(object: JsonMarkdownCodeblock, file: string, normalizer?: LinkNormalizer): MarkdownCodeblock;
    // @internal (undocumented)
    json(): JsonMarkdownCodeblock;
    // (undocumented)
    static readableId(file: string, line: number): string;
    // (undocumented)
    static SUB_FIELD_DEF: FieldExtractor<MarkdownCodeblock>;
    // (undocumented)
    static TYPES: string[];
    value(key: string): Literal | undefined;
}

// @public
export class MarkdownDatablock extends MarkdownBlock implements Indexable, Fieldbearing, Linkbearing {
    // (undocumented)
    $data: Record<string, FrontmatterEntry>;
    // (undocumented)
    $types: string[];
    constructor(init: Partial<MarkdownDatablock>);
    field(key: string): Field;
    get fields(): Field[];
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownDatablock" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    static from(object: JsonMarkdownDatablock, file: string, normalizer?: LinkNormalizer): MarkdownDatablock;
    // @internal (undocumented)
    json(): JsonMarkdownDatablock;
    // (undocumented)
    static readableId(file: string, line: number): string;
    // (undocumented)
    static SUB_FIELD_DEF: FieldExtractor<MarkdownDatablock>;
    // (undocumented)
    static TYPES: string[];
    // (undocumented)
    value(key: string): Literal | undefined;
}

// @public
export class MarkdownListBlock extends MarkdownBlock implements Taggable, Linkbearing {
    $elements: MarkdownListItem[];
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    constructor(init: Partial<MarkdownListBlock>);
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownListBlock" needs to be exported by the entry point index.d.ts
    //
    // @internal
    static from(object: JsonMarkdownListBlock, file: string, normalizer?: LinkNormalizer): MarkdownListBlock;
    // @internal (undocumented)
    json(): JsonMarkdownListBlock;
    // (undocumented)
    static TYPES: string[];
}

// @public
export class MarkdownListItem implements Indexable, Linkbearing, Taggable, Fieldbearing {
    $blockId?: string;
    get $cleantext(): string;
    $elements: MarkdownListItem[];
    // (undocumented)
    $file: string;
    // (undocumented)
    $id: string;
    $infields: Record<string, InlineField>;
    get $line(): number;
    get $lineCount(): number;
    $links: Link[];
    $parentLine: number;
    $position: LineSpan;
    $symbol?: string;
    $tags: string[];
    $text?: string;
    $type: string;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    protected constructor(init: Partial<MarkdownListItem>);
    field(key: string): Field;
    get fields(): Field[];
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownListItem" needs to be exported by the entry point index.d.ts
    //
    // @internal
    static from(object: JsonMarkdownListItem, file: string, normalizer?: LinkNormalizer): MarkdownListItem;
    // @internal (undocumented)
    json(): JsonMarkdownListItem;
    static readableId(file: string, line: number): string;
    // (undocumented)
    static TYPES: string[];
    // (undocumented)
    value(key: string): Literal | undefined;
}

// @public
export class MarkdownPage implements File_2, Linkbearing, Taggable, Indexable, Fieldbearing {
    $ctime: DateTime;
    $extension: string;
    // (undocumented)
    get $file(): string;
    $frontmatter?: Record<string, FrontmatterEntry>;
    // (undocumented)
    get $id(): string;
    $infields: Record<string, InlineField>;
    get $lineCount(): number;
    get $link(): Link;
    $links: Link[];
    $mtime: DateTime;
    get $name(): string;
    $path: string;
    $position: LineSpan;
    $sections: MarkdownSection[];
    $size: number;
    $tags: string[];
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    field(key: string): Field | undefined;
    get fields(): Field[];
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownPage" needs to be exported by the entry point index.d.ts
    //
    // @internal
    static from(raw: JsonMarkdownPage, normalizer?: LinkNormalizer): MarkdownPage;
    // @internal
    json(): JsonMarkdownPage;
    static TYPES: string[];
    value(key: string): Literal | undefined;
}

// @public
export class MarkdownSection implements Indexable, Taggable, Linkable, Linkbearing, Fieldbearing {
    $blocks: MarkdownBlock[];
    // (undocumented)
    $file: string;
    // (undocumented)
    $id: string;
    $infields: Record<string, InlineField>;
    $level: number;
    get $lineCount(): number;
    get $link(): Link;
    $links: Link[];
    get $name(): string;
    $ordinal: number;
    $position: LineSpan;
    $tags: string[];
    $title: string;
    // (undocumented)
    $typename: string;
    $types: string[];
    field(key: string): Field;
    get fields(): Field[];
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownSection" needs to be exported by the entry point index.d.ts
    //
    // @internal
    static from(raw: JsonMarkdownSection, file: string, normalizer?: LinkNormalizer): MarkdownSection;
    // @internal (undocumented)
    json(): JsonMarkdownSection;
    static readableId(file: string, title: string, ordinal: number): string;
    static TYPES: string[];
    // (undocumented)
    value(key: string): Literal | undefined;
}

// @public
export class MarkdownTaskItem extends MarkdownListItem implements Indexable, Linkbearing, Taggable, Fieldbearing {
    get $completed(): boolean;
    $status: string;
    // (undocumented)
    $typename: string;
    // (undocumented)
    $types: string[];
    constructor(init: Partial<MarkdownTaskItem>);
    // Warning: (ae-forgotten-export) The symbol "JsonMarkdownTaskItem" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    static from(object: JsonMarkdownTaskItem, file: string, normalizer: LinkNormalizer): MarkdownTaskItem;
    // @internal (undocumented)
    json(): JsonMarkdownListItem;
    // (undocumented)
    static TYPES: string[];
}

// @public
export interface MethodExpression {
    arguments: Expression[];
    func: string;
    target: Expression;
    // (undocumented)
    type: "method";
}

// @public
export interface NegatedExpression {
    child: Expression;
    // (undocumented)
    type: "negated";
}

// Warning: (ae-internal-missing-underscore) The name "NOOP_NORMALIZER" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const NOOP_NORMALIZER: LinkNormalizer;

// Warning: (ae-internal-missing-underscore) The name "normalizeLinks" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function normalizeLinks<T>(input: T, normalizer: LinkNormalizer): T;

// @public
export interface ObjectExpression {
    // (undocumented)
    type: "object";
    // (undocumented)
    values: Record<string, Expression>;
}

// @public
export type Provenance = {
    type: "frontmatter";
    file: string;
    key: string;
    revision: number;
} | {
    type: "inline-field";
    file: string;
    line: number;
    key: string;
    revision: number;
} | {
    type: "intrinsic";
    file: string;
    revision: number;
};

// @public
export type Result<T, E> = Success<T, E> | Failure<T, E>;

// @public
export namespace Result {
    export function async<T>(promise: Promise<T>): Promise<Result<T, Error>>;
    export function failure<T, E>(error: E): Result<T, E>;
    export function flatMap2<T1, T2, O, E>(first: Result<T1, E>, second: Result<T2, E>, f: (a: T1, b: T2) => Result<O, E>): Result<O, E>;
    export function map2<T1, T2, O, E>(first: Result<T1, E>, second: Result<T2, E>, f: (a: T1, b: T2) => O): Result<O, E>;
    export function mapAll<T, O, E>(input: Iterable<T>, func: (input: T) => Result<O, E>): Result<O[], E>;
    export function success<T, E>(value: T): Result<T, E>;
    export function trying<T>(call: () => T): Result<T, Error>;
}

// @public
export interface SearchResult<O> {
    duration: number;
    query: IndexQuery;
    results: O[];
    revision: number;
}

// Warning: (ae-internal-missing-underscore) The name "Settings" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface Settings {
    defaultDateFormat: string;
    defaultDateTimeFormat: string;
    defaultPageSize: number;
    defaultPagingEnabled: boolean;
    enableJs: boolean;
    importerNumThreads: number;
    importerUtilization: number;
    indexInlineFields: boolean;
    indexListItems: boolean;
    maxRecursiveRenderDepth: number;
    renderNullAs: string;
    scrollOnPageChange: boolean;
}

// @public
export function Slider(props: {
    className?: string;
    min?: number;
    max?: number;
    step?: number;
    value?: number;
    defaultValue?: number;
    onValueChange?: (value: number) => void;
} & React_2.ComponentProps<"input">): React_2.JSX.Element;

// @public
export function Stack(props: HTMLAttributes<HTMLDivElement> & {
    className?: string;
    justify?: string;
    align?: string;
    style?: string;
}): JSX.Element;

// @public
export class Success<T, E> {
    constructor(value: T);
    // (undocumented)
    bimap<T2, E2>(succ: (a: T) => T2, _fail: (b: E) => E2): Result<T2, E2>;
    // (undocumented)
    cast<U>(): Result<U, E>;
    // (undocumented)
    castErr<U>(): Result<T, U>;
    // (undocumented)
    flatMap<U>(f: (a: T) => Result<U, E>): Result<U, E>;
    // (undocumented)
    map<U>(f: (a: T) => U): Result<U, E>;
    // (undocumented)
    mapErr<U>(f: (e: E) => U): Result<T, U>;
    // (undocumented)
    orElse(_value: T): T;
    // (undocumented)
    orElseThrow(_message?: (e: E) => string): T;
    // (undocumented)
    successful: true;
    // (undocumented)
    value: T;
}

// @public
export function Switch(props: {
    className?: string;
    disabled?: boolean;
    checked?: boolean;
    defaultChecked?: boolean;
    onToggleChange?: (checked: boolean) => void;
} & React_2.ComponentProps<"input">): React_2.JSX.Element;

// @public
export interface TableColumn<T, V = Literal> {
    id: string;
    render?: (value: V, object: T) => Literal | ReactNode;
    title?: string | ReactNode | (() => string | ReactNode);
    value: (object: T) => V;
    width?: "minimum" | "maximum" | string;
}

// @public
export function TableView<T>(props: TableViewProps<T>): JSX_2.Element;

// @public
export interface TableViewProps<T> {
    columns: TableColumn<T>[];
    // Warning: (ae-forgotten-export) The symbol "GroupingConfig" needs to be exported by the entry point index.d.ts
    groupings?: GroupingConfig<T> | GroupingConfig<T>[] | ((key: Literal, rows: Grouping<T>) => Literal | ReactNode);
    paging?: boolean | number;
    rows: Grouping<T>;
    scrollOnPaging?: boolean | number;
}

// @public
export interface Taggable {
    $tags: string[];
}

// @public
export const TAGGABLE_TYPE = "taggable";

// @public
export function Textbox(props: React_2.ComponentProps<"input"> & {
    className?: string;
}): React_2.JSX.Element;

// Warning: (ae-internal-missing-underscore) The name "valueFrontmatterEntry" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function valueFrontmatterEntry(raw: JsonFrontmatterEntry): FrontmatterEntry;

// @public
export function VanillaSelect(props: {
    className?: string;
    options: {
        value: string;
        label: string;
    }[];
    value?: string;
    defaultValue?: string;
    onValueChange?: (value: string) => void;
} & React_2.ComponentProps<"select">): React_2.JSX.Element;

// @public
export interface VariableExpression {
    // (undocumented)
    name: string;
    // (undocumented)
    type: "variable";
}

// @public
export type WrappedLiteral = LiteralWrapper<"string"> | LiteralWrapper<"number"> | LiteralWrapper<"boolean"> | LiteralWrapper<"date"> | LiteralWrapper<"duration"> | LiteralWrapper<"link"> | LiteralWrapper<"array"> | LiteralWrapper<"object"> | LiteralWrapper<"function"> | LiteralWrapper<"null">;

// (No @packageDocumentation comment for this package)

```
